nvr.example.com {
  tls {
    dns cloudflare {
      api_token {file./run/secrets/cf_api_token}
      zone_token {file./run/secrets/cf_zone_token}
    }

    # override resolver to allow for validation of dns challenge
    # https://github.com/caddy-dns/cloudflare/issues/28
    resolvers 1.1.1.1 9.9.9.9

    # increase propagation timeout and delay
    propagation_timeout 10m
    propagation_delay 30s

    # decrease ttl of txt
    dns_ttl 1m

    # lets encrypt doesn't support ed25519 yet
    key_type rsa4096

    protocols tls1.3
  }

  # Requests to /oauth2/* are proxied to oauth2-proxy without authentication.
  # You can't use `reverse_proxy /oauth2/* oauth2-proxy.internal:4180` here because the reverse_proxy directive has lower precedence than the handle directive.
  handle /oauth2/* {
    reverse_proxy oauth2-proxy:4180 {
      # oauth2-proxy requires the X-Real-IP and X-Forwarded-{Proto,Host,Uri} headers.
      # The reverse_proxy directive automatically sets X-Forwarded-{For,Proto,Host} headers.
      header_up X-Real-IP {remote_host}

      header_up X-Forwarded-Uri {uri}
    }
  }

  # Requests to other paths are first processed by oauth2-proxy for authentication.
  handle {
    forward_auth oauth2-proxy:4180 {
      # uri /oauth2/auth # Checking if order
      uri /oauth2/

      # oauth2-proxy requires the X-Real-IP and X-Forwarded-{Proto,Host,Uri} headers.
      # The forward_auth directive automatically sets the X-Forwarded-{For,Proto,Host,Method,Uri} headers.
      header_up X-Real-IP {remote_host}

      # If needed, you can copy headers from the oauth2-proxy response to the request sent to the upstream.
      # Make sure to configure the --set-xauthrequest flag to enable this feature.
      #copy_headers X-Auth-Request-User X-Auth-Request-Email

      # If oauth2-proxy returns a 401 status, redirect the client to the sign-in page.
      @error status 401
      handle_response @error {
        redir * /oauth2/sign_in?rd={scheme}://{host}{uri}
      }
    }
  }

  reverse_proxy nvr:5000
}
